= jsoSchema
Marco Baringer <mb@bese.it>

jsoSchema is a schema language and validator for javascript objects.

Note that jsoSchema is not a JSON text parser/validator; it can
however, and generally is, used with the output of `JSON.parse`.

== Installation ==

How many ways are there to install, compile and deploy js code? too
many; and I have no desire to try and keep up with them
all. Considering that, the code itself is exactly one file of
javascript:

https://raw.github.com/segv/jsoSchema/master/src/jsoSchema.js

which exposes a single global variable, jsoSchema, with all the
neccessary functions and variables as properties on that object. Feel
free, and it is in infact what i'd suggest, to just copy that file
into your own code base.

That said, you can get versions of jsoSchema designed to work with
jquery,
https://raw.github.com/segv/jsoSchema/0.9.3/build/raw/jquery.jsoSchema.js[jquery.jsoSchema.js]
(https://raw.github.com/segv/jsoSchema/0.9.3/build/min/jquery.jsoSchema.js[minified]),
or requirejs (which means dojo),
https://raw.github.com/segv/jsoSchema/0.9.3/build/raw/jso/Schema.js[jso/Schema.js]
(https://raw.github.com/segv/jsoSchema/0.9.3/build/min/jso/Schema.js[minified]).

If you're using the
https://developers.google.com/closure/compiler/[Closure Compiler] you
can just use the source file as is, maybe adding
`goog.provide('jsoSchema')`, the code has the required type
definitions and structure to compile cleanly with
+ADVANCED_OPTIMIZATIONS+, though you might want to remove some of the
string property names which exist only to make sure the public api of
the minified jquery/requestjs files is what is documented here (if
you're using the closure compiler this should all make sense, if not
just don't worry about it).

== Usage ==

It should be pretty simple, create a schema, give it a value, see if
you get +true+ or +false+ back.

Here's a short example, but see
https://raw.github.com/segv/jsoSchema/master/test/examples.js[test/examples.js]
for more examples:

[source,javascript]
----
require([ 'jso/Schema' ], function (s) {
  var schema = s.Record({ name: s.String(), 
                          age: s.Integer() });

  schema.validate({ name: "Me", age: 25 }); // returns true
  schema.validate({ name: "Me" }); // returns false

  schema = s.Array(s.Number());

  schema.validate([1]); // returns true
  schema.validate(["1"]); // returns false

  schema = s.Record({ name: s.String(), 
                      age: s.Or(s.Integer(), 
                                s.Constant("none-given")) });

  schema.validate({ name: "Milhouse" }); // returns false
  schema.validate({ name: "Milhouse", age: 63 }); // returns true
  schema.validate({ name: "Milhouse", age: "none-given" }); // returns true
  schema.validate({ name: "Milhouse", age: false }); // returns false
  schema.validate({ name: "Milhouse", age: -4 }); // returns true

  var age_constraint = s.Condition(function (value) {
    return 23 <= value.age && value.age <= 32;
  };

  schema = s.Record({ age: s.Or(age_constraint, 
                                s.Constant("none-given")) });

  schema.validate({ age: 20 }); // returns false
  schema.validate({ age: "none-given" }); // returns true
  schema.validate({ age: 25 }); // returns true
  schema.validate({ age: 35 }); // returns false


});
----

== Schema Generators ==

Read to code if you want all the details (the code, and not this
README, is what you're actually using, so you you should read that
anyway), but here's a, probably inaccurate and incomplete, summary.

=== Values ===

Number(), String(), Boolean()::
  Checks that the given value's +typeof+ is +"number"+, +"string"+ or +"boolean"+ respectively
OfType(typeName)::
  Checks that the given values's +typeof+ is +==+ to +typeName+
Constant(value)::
  Checks that the given value is +===+ to +value+.E
Enum(...values)::
  Checks that the given value is one of elements of +values+ (as per +===+). This is simply a convenience around OneOf.
OneOf(values)::
  Checks that the given value is one of elements of +values+ (as per +===+). 
Condition(function)::
  Checks that +function+, when applied to the given value, returns a truthy value.

=== Objects ===

Record(properties), Record(properties, optional_properties):: Checks
  that the given value is an object, with the same set of properties
  as +properties+ (no more, no less), and that each of the given
  value's property value checks against the schema in +properties+. If
  the +optional_properties+ argument is present it is passed to the
  underlying +Object+ schema.

  Equivalent to `Object({ required_properties: properties,
  optional_properties: optional_properties, allow_other_properties:
  false })`

HashTable():: Simply checks that the given value is an object.

Object(description):: description is an object with three properties:
  
  required_properties:: a hash table (another object) mapping property
    names to schemas. if the given property is found the corresponding
    schema will be used, if the property is not found or the schema
    fails, the Object schema fails.

  optional_properties:: similar to `required_properties`, a hash table
    mapping property names to schemas, but if the property isn't found
    we don't immediately fail (if the property is found, then the
    schema does have to match the property's value).
  
  allow_other_properties:: a boolean specifying if properties not
    explicitly mentioned in `required_properties` or
    `optional_properties` are allowed. defaults to true.

=== Arrays ===

Array(item), Array(item, length):: Checks that the given value is an
  array, that the value's length checks against +length+ (optional,
  defaults to just +Pass()+) and that each time checks against +item+.
  
Tuple(...items):: An array of length items where each element passes
  the corresponding item schema.

=== Schema Generators ===

Or(a,b):: Creates a schema which passes if either the schema +a+ or
  the schema +b+ pass. Like the normal +||+ operator, schema +b+ will
  be tested only if +a+ fails.

Any(conditions)::
  N-argument version of Or. +conditions+ is simply an array of
  schemas, we stop checking as soon as one of the passes, if none of
  them do we fail.

And(a,b)::
  If the schemas +a+ and +b+ pass, the +And+ schema passes. If +a+
  fails +b+ will not be tested.

Every(conditions)::
  N-argument version of +And+.

== Compared to JSON schema ==

http://tools.ietf.org/html/draft-zyp-json-schema-04

While jsoSchema and JSON Schema server very similar purposes, they go
about it in two very different ways. A JSON Schema is a bit of data
which is passed to a validator, along with the actual data to
validate, and the validator understands the semantics of JSON Schema
and dos what the schema says it should do given the data it has.

a jsoSchema is a block of code describing how to test if something is
valid or not.

This code vs data approach has two important consequences:

1. A JSON Schema can be represented, and transmitted and stored, as
   JSON data; a jsoSchema can not.

2. A jsoSchema can perfrom any computation that's needed; a JSON
   Schema is limited to the constraints defined in the JSON Schema
   specification.

== Defining new schemas ==

If your schema can be expressed as a singe condition on a single
value, just use the Condition schema and be done with it. Otherwise,
read on, and may God have mercy on your soul (unless you eat
continuations for breakfast, then, gutten appetite).

A jso schema is just a 3 argument function: the value to validate,
what to do if the value is valid, and what to do if the value is
invalid. 

Let's pretend, as an example, that you wanted to write the And schema
combiner, but it didn't already exist (what we'll write in this
example is equivalent to the built in And combiner). You might be
tempted to write this:

[source,javascript]
----
  function (a, b) {
    return function (value, p, f) {
      a(value) && b(value) ? p() : f();
    }
  }
----

I can see where you're coming from, and I understand what's going on
in your head, but you're wrong. The problem is in the calls to
`a(value)` and `b(value)`, both of those functions also take a p and f
parameter, but what do we pass them? The thing to realize is that
calling another validator function, or calling `p` or `f`, has to be
the last thing a validator function does (we could enforce this
programatticaly, but it'd make debugging the code a huge pain in the
ass).

so, in this case, we'd like to call `a`, and if that returns true,
then call `b`, but our rule says the call to `a`, which is itself a
validator, has to be the last thing our function does. how can we do
that?

the thing to realize is that a takes, as an input parameter, a
function that it will call if the value checks. that's where we can
put our logic for calling b. so instead of this:

[source,javascript]
----
  a(value) && b(value)
----

we have:

[source,javascript]
----
  a(value,
    function () { b(value, 
                    p); })
----

though we are still not telling a what to do if it fails, fortunetely
that's easy, if `a` fails then we fail, and our `f` parameter is what
to do if we fail. applying the same reasoning to b:

[source,javascript]
----
  a(value,
    function () { b(value, 
                    p,
                    f); },
    f)
----
